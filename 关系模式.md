# 药品存销管理系统关系模式报告

## 一、总体关系模式设计

### 1.1 系统关系模式总览
本系统共设计8个关系模式，涵盖了药品存销管理的所有核心数据。这些关系模式按照功能模块划分，形成了清晰的数据结构层次。

### 1.2 全局关系模式概览
| 关系名         | 别名         | 存储文件            | 功能描述         |
| -------------- | ------------ | ------------------- | ---------------- |
| Medicine       | 药品表       | medicine.dat        | 存储药品基本信息 |
| Supplier       | 供应商表     | supplier.dat        | 存储供应商信息   |
| Stock          | 库存表       | stock.dat           | 存储药品库存信息 |
| PurchaseOrder  | 采购单表     | purchase_order.dat  | 存储采购单主信息 |
| PurchaseDetail | 采购单明细表 | purchase_detail.dat | 存储采购明细信息 |
| SalesOrder     | 销售单表     | sales_order.dat     | 存储销售单主信息 |
| SalesDetail    | 销售单明细表 | sales_detail.dat    | 存储销售明细信息 |
| SystemUser     | 系统用户表   | system_user.dat     | 存储系统用户信息 |

### 1.3 全局关系模式依赖图
```
药品表(Medicine) ──┬── 库存表(Stock)
                   ├── 采购单明细表(PurchaseDetail)
                   └── 销售单明细表(SalesDetail)
                      
供应商表(Supplier) ────── 采购单表(PurchaseOrder)

采购单表(PurchaseOrder) ─── 采购单明细表(PurchaseDetail)

销售单表(SalesOrder) ────── 销售单明细表(SalesDetail)
```

### 1.4 全局完整性约束
1. **实体完整性**：每个表的主键字段必须非空且唯一
2. **参照完整性**：所有外键必须引用已存在的主键值
3. **用户定义完整性**：
   - 药品单价必须≥0
   - 库存数量必须≥0
   - 采购/销售数量必须>0
   - 状态字段必须在指定范围内

---

## 二、A同学：药品与供应商管理子系统关系模式

### 2.1 药品表 (Medicine) 关系模式

#### 2.1.1 关系模式定义
```
Medicine (
    medicine_id      INT            NOT NULL,
    medicine_name    VARCHAR(100)   NOT NULL,
    specification    VARCHAR(50),
    unit             VARCHAR(20),
    manufacturer     VARCHAR(100),
    category         VARCHAR(50),
    price            DECIMAL(10,2),
    status           VARCHAR(10)    DEFAULT '正常',
    PRIMARY KEY (medicine_id)
)
```

#### 2.1.2 属性详细说明
| 属性名        | 含义     | 数据类型 | 长度 | 可空 | 默认值         | 约束条件       |
| ------------- | -------- | -------- | ---- | ---- | -------------- | -------------- |
| medicine_id   | 药品ID   | INT      | -    | 否   | AUTO_INCREMENT | 主键，自动增长 |
| medicine_name | 药品名称 | VARCHAR  | 100  | 否   | -              | 非空，药品全称 |
| specification | 规格     | VARCHAR  | 50   | 是   | -              | 如：10mg×20片  |
| unit          | 单位     | VARCHAR  | 20   | 是   | -              | 计量单位       |
| manufacturer  | 生产厂家 | VARCHAR  | 100  | 是   | -              | 制造商名称     |
| category      | 类别     | VARCHAR  | 50   | 是   | -              | 药品分类       |
| price         | 单价     | DECIMAL  | 10,2 | 是   | 0.00           | ≥0             |
| status        | 状态     | VARCHAR  | 10   | 是   | '正常'         | '正常'或'停用' |

#### 2.1.3 索引设计
```sql
-- 主键索引
CREATE UNIQUE INDEX pk_medicine ON Medicine(medicine_id);

-- 药品名称索引（允许重复但需快速查询）
CREATE INDEX idx_medicine_name ON Medicine(medicine_name);

-- 类别索引（用于分类查询）
CREATE INDEX idx_medicine_category ON Medicine(category);
```

#### 2.1.4 数据依赖分析
- **函数依赖**：
  - medicine_id → {medicine_name, specification, unit, manufacturer, category, price, status}
  - medicine_name → medicine_id (不完全依赖，允许同名但规格不同)
- **多值依赖**：无
- **连接依赖**：无

### 2.2 供应商表 (Supplier) 关系模式

#### 2.2.1 关系模式定义
```
Supplier (
    supplier_id      INT            NOT NULL,
    supplier_name    VARCHAR(100)   NOT NULL,
    contact          VARCHAR(50),
    phone            VARCHAR(20),
    address          VARCHAR(200),
    status           VARCHAR(10)    DEFAULT '合作中',
    PRIMARY KEY (supplier_id)
)
```

#### 2.2.2 属性详细说明
| 属性名        | 含义       | 数据类型 | 长度 | 可空 | 默认值         | 约束条件           |
| ------------- | ---------- | -------- | ---- | ---- | -------------- | ------------------ |
| supplier_id   | 供应商ID   | INT      | -    | 否   | AUTO_INCREMENT | 主键，自动增长     |
| supplier_name | 供应商名称 | VARCHAR  | 100  | 否   | -              | 非空               |
| contact       | 联系人     | VARCHAR  | 50   | 是   | -              | 对接人姓名         |
| phone         | 电话       | VARCHAR  | 20   | 是   | -              | 联系方式           |
| address       | 地址       | VARCHAR  | 200  | 是   | -              | 供应商地址         |
| status        | 状态       | VARCHAR  | 10   | 是   | '合作中'       | '合作中'或'已终止' |

#### 2.2.3 索引设计
```sql
-- 主键索引
CREATE UNIQUE INDEX pk_supplier ON Supplier(supplier_id);

-- 供应商名称索引
CREATE INDEX idx_supplier_name ON Supplier(supplier_name);

-- 状态索引（用于筛选合作中的供应商）
CREATE INDEX idx_supplier_status ON Supplier(status);
```

#### 2.2.4 数据依赖分析
- **函数依赖**：
  - supplier_id → {supplier_name, contact, phone, address, status}
  - supplier_name → supplier_id (不完全依赖)
- **多值依赖**：无
- **连接依赖**：无

### 2.3 A同学子系统关系模式特点

#### 2.3.1 规范化程度分析
- **药品表**：符合BCNF范式
  - 所有属性完全函数依赖于主键
  - 不存在非平凡多值依赖
- **供应商表**：符合BCNF范式
  - 所有属性完全函数依赖于主键
  - 不存在传递依赖

#### 2.3.2 数据完整性约束
```sql
-- 药品表约束
ALTER TABLE Medicine
ADD CONSTRAINT chk_medicine_price CHECK (price >= 0),
ADD CONSTRAINT chk_medicine_status CHECK (status IN ('正常', '停用'));

-- 供应商表约束
ALTER TABLE Supplier
ADD CONSTRAINT chk_supplier_status CHECK (status IN ('合作中', '已终止'));
```

#### 2.3.3 数据操作权限
- **插入权限**：仅限于管理员角色
- **更新权限**：仅限于管理员角色
- **删除权限**：逻辑删除（更新状态），不物理删除
- **查询权限**：所有角色均可查询

---

## 三、B同学：采购与入库管理子系统关系模式

### 3.1 采购单表 (PurchaseOrder) 关系模式

#### 3.1.1 关系模式定义
```
PurchaseOrder (
    purchase_id      INT            NOT NULL,
    supplier_id      INT            NOT NULL,
    purchase_date    DATE           NOT NULL,
    total_amount     DECIMAL(12,2),
    status           VARCHAR(20)    DEFAULT '待入库',
    create_time      DATETIME,
    PRIMARY KEY (purchase_id),
    FOREIGN KEY (supplier_id) REFERENCES Supplier(supplier_id)
)
```

#### 3.1.2 属性详细说明
| 属性名        | 含义     | 数据类型 | 长度 | 可空 | 默认值            | 约束条件                       |
| ------------- | -------- | -------- | ---- | ---- | ----------------- | ------------------------------ |
| purchase_id   | 采购单ID | INT      | -    | 否   | AUTO_INCREMENT    | 主键，自动增长                 |
| supplier_id   | 供应商ID | INT      | -    | 否   | -                 | 外键，引用Supplier.supplier_id |
| purchase_date | 采购日期 | DATE     | -    | 否   | CURDATE()         | 采购发生日期                   |
| total_amount  | 总金额   | DECIMAL  | 12,2 | 是   | 0.00              | ≥0，自动计算                   |
| status        | 状态     | VARCHAR  | 20   | 是   | '待入库'          | '待入库'/'已完成'/'已取消'     |
| create_time   | 创建时间 | DATETIME | -    | 是   | CURRENT_TIMESTAMP | 记录创建时间                   |

#### 3.1.3 索引设计
```sql
-- 主键索引
CREATE UNIQUE INDEX pk_purchase_order ON PurchaseOrder(purchase_id);

-- 供应商外键索引
CREATE INDEX idx_purchase_supplier ON PurchaseOrder(supplier_id);

-- 日期索引（按日期查询采购单）
CREATE INDEX idx_purchase_date ON PurchaseOrder(purchase_date);

-- 状态索引（筛选待入库的采购单）
CREATE INDEX idx_purchase_status ON PurchaseOrder(status);
```

### 3.2 采购单明细表 (PurchaseDetail) 关系模式

#### 3.2.1 关系模式定义
```
PurchaseDetail (
    purchase_detail_id INT          NOT NULL,
    purchase_id      INT            NOT NULL,
    medicine_id      INT            NOT NULL,
    quantity         INT            NOT NULL,
    unit_price       DECIMAL(10,2)  NOT NULL,
    amount           DECIMAL(10,2),
    remark           VARCHAR(200),
    PRIMARY KEY (purchase_detail_id),
    FOREIGN KEY (purchase_id) REFERENCES PurchaseOrder(purchase_id),
    FOREIGN KEY (medicine_id) REFERENCES Medicine(medicine_id)
)
```

#### 3.2.2 属性详细说明
| 属性名             | 含义       | 数据类型 | 长度 | 可空 | 默认值         | 约束条件                            |
| ------------------ | ---------- | -------- | ---- | ---- | -------------- | ----------------------------------- |
| purchase_detail_id | 采购明细ID | INT      | -    | 否   | AUTO_INCREMENT | 主键，自动增长                      |
| purchase_id        | 采购单ID   | INT      | -    | 否   | -              | 外键，引用PurchaseOrder.purchase_id |
| medicine_id        | 药品ID     | INT      | -    | 否   | -              | 外键，引用Medicine.medicine_id      |
| quantity           | 数量       | INT      | -    | 否   | -              | >0                                  |
| unit_price         | 采购单价   | DECIMAL  | 10,2 | 否   | -              | ≥0                                  |
| amount             | 金额       | DECIMAL  | 10,2 | 是   | -              | 自动计算=quantity*unit_price        |
| remark             | 备注       | VARCHAR  | 200  | 是   | -              | 其他说明                            |

#### 3.2.3 索引设计
```sql
-- 主键索引
CREATE UNIQUE INDEX pk_purchase_detail ON PurchaseDetail(purchase_detail_id);

-- 采购单外键索引（快速查询某个采购单的明细）
CREATE INDEX idx_purchase_detail_order ON PurchaseDetail(purchase_id);

-- 药品外键索引
CREATE INDEX idx_purchase_detail_medicine ON PurchaseDetail(medicine_id);

-- 组合索引（按采购单和药品查询）
CREATE INDEX idx_purchase_order_medicine ON PurchaseDetail(purchase_id, medicine_id);
```

### 3.3 B同学子系统关系模式特点

#### 3.3.1 关系模式规范化分析
- **采购单表**：符合3NF范式
  - 满足2NF（所有非主属性完全函数依赖于主键）
  - 满足3NF（不存在传递依赖）
- **采购单明细表**：符合3NF范式
  - amount字段存在函数依赖：amount = quantity * unit_price
  - 但为了查询性能，保留冗余字段

#### 3.3.2 完整性约束
```sql
-- 采购单表约束
ALTER TABLE PurchaseOrder
ADD CONSTRAINT chk_purchase_total_amount CHECK (total_amount >= 0),
ADD CONSTRAINT chk_purchase_status CHECK (status IN ('待入库', '已完成', '已取消'));

-- 采购单明细表约束
ALTER TABLE PurchaseDetail
ADD CONSTRAINT chk_purchase_quantity CHECK (quantity > 0),
ADD CONSTRAINT chk_purchase_unit_price CHECK (unit_price >= 0),
ADD CONSTRAINT chk_purchase_amount CHECK (amount >= 0);

-- 触发器：自动计算采购明细金额
CREATE TRIGGER trg_calc_purchase_amount
BEFORE INSERT OR UPDATE ON PurchaseDetail
FOR EACH ROW
SET NEW.amount = NEW.quantity * NEW.unit_price;

-- 触发器：更新采购单总金额
CREATE TRIGGER trg_update_purchase_total
AFTER INSERT OR UPDATE OR DELETE ON PurchaseDetail
FOR EACH ROW
BEGIN
    UPDATE PurchaseOrder po
    SET total_amount = (
        SELECT COALESCE(SUM(amount), 0)
        FROM PurchaseDetail pd
        WHERE pd.purchase_id = po.purchase_id
    )
    WHERE po.purchase_id = COALESCE(NEW.purchase_id, OLD.purchase_id);
END;
```

#### 3.3.3 数据依赖关系
```
PurchaseOrder (1) ── (n) PurchaseDetail
    │                         │
    │ (FK: supplier_id)       │ (FK: medicine_id)
    ↓                         ↓
Supplier (1) ──────── (n) Medicine
```

#### 3.3.4 数据操作特性
- **插入特性**：先插入PurchaseOrder，再插入PurchaseDetail
- **更新特性**：PurchaseDetail更新会触发PurchaseOrder.total_amount更新
- **删除特性**：级联删除或限制删除（根据业务规则）

---

## 四、C同学：库存与盘点管理子系统关系模式

### 4.1 库存表 (Stock) 关系模式

#### 4.1.1 关系模式定义
```
Stock (
    stock_id         INT            NOT NULL,
    medicine_id      INT            NOT NULL,
    current_quantity INT            NOT NULL,
    min_quantity     INT,
    max_quantity     INT,
    location         VARCHAR(50),
    update_time      DATETIME,
    status           VARCHAR(10)    DEFAULT '正常',
    PRIMARY KEY (stock_id),
    FOREIGN KEY (medicine_id) REFERENCES Medicine(medicine_id),
    UNIQUE (medicine_id)  -- 一种药品只有一个库存记录
)
```

#### 4.1.2 属性详细说明
| 属性名           | 含义     | 数据类型 | 长度 | 可空 | 默认值            | 约束条件                       |
| ---------------- | -------- | -------- | ---- | ---- | ----------------- | ------------------------------ |
| stock_id         | 库存ID   | INT      | -    | 否   | AUTO_INCREMENT    | 主键，自动增长                 |
| medicine_id      | 药品ID   | INT      | -    | 否   | -                 | 外键，引用Medicine.medicine_id |
| current_quantity | 当前库存 | INT      | -    | 否   | 0                 | ≥0                             |
| min_quantity     | 最低库存 | INT      | -    | 是   | 10                | ≥0                             |
| max_quantity     | 最高库存 | INT      | -    | 是   | 1000              | ≥min_quantity                  |
| location         | 存放位置 | VARCHAR  | 50   | 是   | -                 | 仓库中的具体位置               |
| update_time      | 更新时间 | DATETIME | -    | 是   | CURRENT_TIMESTAMP | 最后更新时间                   |
| status           | 状态     | VARCHAR  | 10   | 是   | '正常'            | '正常'/'缺货'/'积压'           |

#### 4.1.3 索引设计
```sql
-- 主键索引
CREATE UNIQUE INDEX pk_stock ON Stock(stock_id);

-- 药品唯一索引（确保一种药品只有一个库存记录）
CREATE UNIQUE INDEX uk_stock_medicine ON Stock(medicine_id);

-- 位置索引（按位置查询库存）
CREATE INDEX idx_stock_location ON Stock(location);

-- 状态索引（快速查询缺货或积压药品）
CREATE INDEX idx_stock_status ON Stock(status);

-- 组合索引（按药品和数量范围查询）
CREATE INDEX idx_stock_medicine_quantity ON Stock(medicine_id, current_quantity);
```

#### 4.1.4 触发器设计
```sql
-- 触发器：自动更新库存状态
CREATE TRIGGER trg_update_stock_status
BEFORE INSERT OR UPDATE ON Stock
FOR EACH ROW
BEGIN
    -- 自动设置更新时间
    SET NEW.update_time = CURRENT_TIMESTAMP;
    
    -- 自动更新库存状态
    IF NEW.current_quantity <= 0 THEN
        SET NEW.status = '缺货';
    ELSEIF NEW.current_quantity <= NEW.min_quantity THEN
        SET NEW.status = '预警';
    ELSEIF NEW.current_quantity >= NEW.max_quantity THEN
        SET NEW.status = '积压';
    ELSE
        SET NEW.status = '正常';
    END IF;
END;
```

### 4.2 C同学子系统关系模式特点

#### 4.2.1 规范化分析
- **库存表**：符合3NF范式
  - 所有非主属性完全函数依赖于主键
  - 不存在传递依赖
  - status属性部分依赖于业务规则，但为保持实时性而设计

#### 4.2.2 完整性约束
```sql
-- 库存表约束
ALTER TABLE Stock
ADD CONSTRAINT chk_stock_quantity CHECK (current_quantity >= 0),
ADD CONSTRAINT chk_stock_min_quantity CHECK (min_quantity >= 0),
ADD CONSTRAINT chk_stock_max_quantity CHECK (max_quantity >= min_quantity),
ADD CONSTRAINT chk_stock_status CHECK (status IN ('正常', '缺货', '预警', '积压'));

-- 药品与库存的一对一关系约束
-- 通过UNIQUE(medicine_id)已实现
```

#### 4.2.3 数据依赖关系
```
Medicine (1) ──── (1) Stock
   │
   ├── (n) PurchaseDetail
   │        │
   │        ├── (FK: purchase_id)
   │        │        │
   │        └── PurchaseOrder (n) ─── (1) Supplier
   │
   └── (n) SalesDetail
            │
            ├── (FK: sales_id)
            │        │
            └── SalesOrder
```

#### 4.2.4 库存更新操作
```sql
-- 入库操作：增加库存
UPDATE Stock 
SET current_quantity = current_quantity + :in_quantity
WHERE medicine_id = :medicine_id;

-- 出库操作：减少库存（需先检查库存充足性）
UPDATE Stock 
SET current_quantity = current_quantity - :out_quantity
WHERE medicine_id = :medicine_id 
  AND current_quantity >= :out_quantity;

-- 盘点调整操作：直接设置库存
UPDATE Stock 
SET current_quantity = :new_quantity
WHERE medicine_id = :medicine_id;
```

#### 4.2.5 库存查询优化
```sql
-- 查询库存状态（包含药品信息）
SELECT 
    m.medicine_name,
    m.specification,
    m.unit,
    s.current_quantity,
    s.min_quantity,
    s.max_quantity,
    s.location,
    s.status
FROM Stock s
JOIN Medicine m ON s.medicine_id = m.medicine_id
WHERE s.current_quantity <= s.min_quantity  -- 库存预警查询
   OR s.current_quantity >= s.max_quantity  -- 库存积压查询
ORDER BY s.current_quantity ASC;
```

---

## 五、D同学：销售与出库管理子系统关系模式

### 5.1 销售单表 (SalesOrder) 关系模式

#### 5.1.1 关系模式定义
```
SalesOrder (
    sales_id         INT            NOT NULL,
    customer_name    VARCHAR(100),
    sales_date       DATE           NOT NULL,
    total_amount     DECIMAL(12,2),
    status           VARCHAR(20)    DEFAULT '待出库',
    create_time      DATETIME,
    PRIMARY KEY (sales_id)
)
```

#### 5.1.2 属性详细说明
| 属性名        | 含义     | 数据类型 | 长度 | 可空 | 默认值            | 约束条件                   |
| ------------- | -------- | -------- | ---- | ---- | ----------------- | -------------------------- |
| sales_id      | 销售单ID | INT      | -    | 否   | AUTO_INCREMENT    | 主键，自动增长             |
| customer_name | 客户名称 | VARCHAR  | 100  | 是   | -                 | 购买客户名称               |
| sales_date    | 销售日期 | DATE     | -    | 否   | CURDATE()         | 销售发生日期               |
| total_amount  | 总金额   | DECIMAL  | 12,2 | 是   | 0.00              | ≥0，自动计算               |
| status        | 状态     | VARCHAR  | 20   | 是   | '待出库'          | '待出库'/'已完成'/'已退货' |
| create_time   | 创建时间 | DATETIME | -    | 是   | CURRENT_TIMESTAMP | 记录创建时间               |

#### 5.1.3 索引设计
```sql
-- 主键索引
CREATE UNIQUE INDEX pk_sales_order ON SalesOrder(sales_id);

-- 客户名称索引（按客户查询销售记录）
CREATE INDEX idx_sales_customer ON SalesOrder(customer_name);

-- 日期索引（按日期查询销售单）
CREATE INDEX idx_sales_date ON SalesOrder(sales_date);

-- 状态索引（筛选待出库的销售单）
CREATE INDEX idx_sales_status ON SalesOrder(status);
```

### 5.2 销售单明细表 (SalesDetail) 关系模式

#### 5.2.1 关系模式定义
```
SalesDetail (
    sales_detail_id  INT            NOT NULL,
    sales_id         INT            NOT NULL,
    medicine_id      INT            NOT NULL,
    quantity         INT            NOT NULL,
    unit_price       DECIMAL(10,2)  NOT NULL,
    amount           DECIMAL(10,2),
    remark           VARCHAR(200),
    PRIMARY KEY (sales_detail_id),
    FOREIGN KEY (sales_id) REFERENCES SalesOrder(sales_id),
    FOREIGN KEY (medicine_id) REFERENCES Medicine(medicine_id)
)
```

#### 5.2.2 属性详细说明
| 属性名          | 含义       | 数据类型 | 长度 | 可空 | 默认值         | 约束条件                       |
| --------------- | ---------- | -------- | ---- | ---- | -------------- | ------------------------------ |
| sales_detail_id | 销售明细ID | INT      | -    | 否   | AUTO_INCREMENT | 主键，自动增长                 |
| sales_id        | 销售单ID   | INT      | -    | 否   | -              | 外键，引用SalesOrder.sales_id  |
| medicine_id     | 药品ID     | INT      | -    | 否   | -              | 外键，引用Medicine.medicine_id |
| quantity        | 数量       | INT      | -    | 否   | -              | >0                             |
| unit_price      | 销售单价   | DECIMAL  | 10,2 | 否   | -              | ≥0                             |
| amount          | 金额       | DECIMAL  | 10,2 | 是   | -              | 自动计算=quantity*unit_price   |
| remark          | 备注       | VARCHAR  | 200  | 是   | -              | 其他说明                       |

#### 5.2.3 索引设计
```sql
-- 主键索引
CREATE UNIQUE INDEX pk_sales_detail ON SalesDetail(sales_detail_id);

-- 销售单外键索引（快速查询某个销售单的明细）
CREATE INDEX idx_sales_detail_order ON SalesDetail(sales_id);

-- 药品外键索引
CREATE INDEX idx_sales_detail_medicine ON SalesDetail(medicine_id);

-- 组合索引（按销售单和药品查询）
CREATE INDEX idx_sales_order_medicine ON SalesDetail(sales_id, medicine_id);
```

### 5.3 D同学子系统关系模式特点

#### 5.3.1 规范化分析
- **销售单表**：符合3NF范式
  - 所有非主属性完全函数依赖于主键
  - 不存在传递依赖
- **销售单明细表**：符合3NF范式
  - amount字段存在函数依赖，但为查询性能保留

#### 5.3.2 完整性约束
```sql
-- 销售单表约束
ALTER TABLE SalesOrder
ADD CONSTRAINT chk_sales_total_amount CHECK (total_amount >= 0),
ADD CONSTRAINT chk_sales_status CHECK (status IN ('待出库', '已完成', '已退货'));

-- 销售单明细表约束
ALTER TABLE SalesDetail
ADD CONSTRAINT chk_sales_quantity CHECK (quantity > 0),
ADD CONSTRAINT chk_sales_unit_price CHECK (unit_price >= 0),
ADD CONSTRAINT chk_sales_amount CHECK (amount >= 0);

-- 触发器：自动计算销售明细金额
CREATE TRIGGER trg_calc_sales_amount
BEFORE INSERT OR UPDATE ON SalesDetail
FOR EACH ROW
SET NEW.amount = NEW.quantity * NEW.unit_price;

-- 触发器：更新销售单总金额
CREATE TRIGGER trg_update_sales_total
AFTER INSERT OR UPDATE OR DELETE ON SalesDetail
FOR EACH ROW
BEGIN
    UPDATE SalesOrder so
    SET total_amount = (
        SELECT COALESCE(SUM(amount), 0)
        FROM SalesDetail sd
        WHERE sd.sales_id = so.sales_id
    )
    WHERE so.sales_id = COALESCE(NEW.sales_id, OLD.sales_id);
END;
```

#### 5.3.3 库存检查约束
```sql
-- 检查库存是否充足的存储过程
CREATE PROCEDURE check_stock_for_sales(
    IN p_medicine_id INT,
    IN p_quantity INT,
    OUT p_is_available BOOLEAN,
    OUT p_current_stock INT
)
BEGIN
    DECLARE v_current_quantity INT;
    
    -- 查询当前库存
    SELECT current_quantity INTO v_current_quantity
    FROM Stock
    WHERE medicine_id = p_medicine_id;
    
    IF v_current_quantity IS NULL THEN
        SET p_current_stock = 0;
        SET p_is_available = FALSE;
    ELSEIF v_current_quantity >= p_quantity THEN
        SET p_current_stock = v_current_quantity;
        SET p_is_available = TRUE;
    ELSE
        SET p_current_stock = v_current_quantity;
        SET p_is_available = FALSE;
    END IF;
END;

-- 在插入销售明细前检查库存的触发器
CREATE TRIGGER trg_check_stock_before_sales
BEFORE INSERT ON SalesDetail
FOR EACH ROW
BEGIN
    DECLARE v_current_quantity INT;
    DECLARE v_is_available BOOLEAN;
    
    -- 调用存储过程检查库存
    CALL check_stock_for_sales(NEW.medicine_id, NEW.quantity, v_is_available, v_current_quantity);
    
    IF NOT v_is_available THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = CONCAT('库存不足，当前库存：', v_current_quantity, '，需要：', NEW.quantity);
    END IF;
END;
```

#### 5.3.4 数据依赖关系
```
SalesOrder (1) ── (n) SalesDetail
                         │
                         │ (FK: medicine_id)
                         ↓
                    Medicine (1) ─── (1) Stock
```

#### 5.3.5 销售数据统计查询
```sql
-- 按药品统计销售量
SELECT 
    m.medicine_name,
    SUM(sd.quantity) as total_sold_quantity,
    SUM(sd.amount) as total_sold_amount,
    COUNT(DISTINCT so.sales_id) as order_count
FROM SalesDetail sd
JOIN Medicine m ON sd.medicine_id = m.medicine_id
JOIN SalesOrder so ON sd.sales_id = so.sales_id
WHERE so.status = '已完成'
  AND so.sales_date BETWEEN :start_date AND :end_date
GROUP BY m.medicine_id, m.medicine_name
ORDER BY total_sold_quantity DESC;
```

---

## 六、系统用户表关系模式

### 6.1 关系模式定义
```
SystemUser (
    user_id          INT            NOT NULL,
    username         VARCHAR(50)    NOT NULL,
    password         VARCHAR(100)   NOT NULL,
    role             VARCHAR(20)    NOT NULL,
    real_name        VARCHAR(50),
    phone            VARCHAR(20),
    status           VARCHAR(10)    DEFAULT '正常',
    PRIMARY KEY (user_id),
    UNIQUE (username)
)
```

### 6.2 属性详细说明
| 属性名    | 含义     | 数据类型 | 长度 | 可空 | 默认值         | 约束条件                            |
| --------- | -------- | -------- | ---- | ---- | -------------- | ----------------------------------- |
| user_id   | 用户ID   | INT      | -    | 否   | AUTO_INCREMENT | 主键，自动增长                      |
| username  | 用户名   | VARCHAR  | 50   | 否   | -              | 唯一，用于登录                      |
| password  | 密码     | VARCHAR  | 100  | 否   | -              | 加密存储                            |
| role      | 角色     | VARCHAR  | 20   | 否   | -              | '管理员'/'采购员'/'库管员'/'销售员' |
| real_name | 真实姓名 | VARCHAR  | 50   | 是   | -              | 用户真实姓名                        |
| phone     | 电话     | VARCHAR  | 20   | 是   | -              | 联系方式                            |
| status    | 状态     | VARCHAR  | 10   | 是   | '正常'         | '正常'/'停用'                       |

### 6.3 完整性约束
```sql
-- 系统用户表约束
ALTER TABLE SystemUser
ADD CONSTRAINT chk_user_role CHECK (role IN ('管理员', '采购员', '库管员', '销售员')),
ADD CONSTRAINT chk_user_status CHECK (status IN ('正常', '停用'));

-- 用户名唯一约束
ALTER TABLE SystemUser
ADD CONSTRAINT uk_username UNIQUE (username);
```

---

## 七、系统全局关系模式总结

### 7.1 关系模式汇总表
| 关系名         | 主键               | 外键                     | 索引数量 | 记录估计   | 存储大小估计 |
| -------------- | ------------------ | ------------------------ | -------- | ---------- | ------------ |
| Medicine       | medicine_id        | 无                       | 3        | 1000条     | 约200KB      |
| Supplier       | supplier_id        | 无                       | 3        | 100条      | 约50KB       |
| Stock          | stock_id           | medicine_id              | 5        | 1000条     | 约150KB      |
| PurchaseOrder  | purchase_id        | supplier_id              | 4        | 5000条/年  | 约500KB      |
| PurchaseDetail | purchase_detail_id | purchase_id, medicine_id | 4        | 20000条/年 | 约2MB        |
| SalesOrder     | sales_id           | 无                       | 4        | 10000条/年 | 约1MB        |
| SalesDetail    | sales_detail_id    | sales_id, medicine_id    | 4        | 40000条/年 | 约4MB        |
| SystemUser     | user_id            | 无                       | 2        | 10条       | 约5KB        |

### 7.2 全局参照完整性约束
```sql
-- 采购单表外键约束
ALTER TABLE PurchaseOrder
ADD CONSTRAINT fk_purchase_supplier 
FOREIGN KEY (supplier_id) REFERENCES Supplier(supplier_id)
ON UPDATE CASCADE
ON DELETE RESTRICT;

-- 采购单明细表外键约束
ALTER TABLE PurchaseDetail
ADD CONSTRAINT fk_purchase_detail_order 
FOREIGN KEY (purchase_id) REFERENCES PurchaseOrder(purchase_id)
ON UPDATE CASCADE
ON DELETE CASCADE;

ALTER TABLE PurchaseDetail
ADD CONSTRAINT fk_purchase_detail_medicine 
FOREIGN KEY (medicine_id) REFERENCES Medicine(medicine_id)
ON UPDATE CASCADE
ON DELETE RESTRICT;

-- 库存表外键约束
ALTER TABLE Stock
ADD CONSTRAINT fk_stock_medicine 
FOREIGN KEY (medicine_id) REFERENCES Medicine(medicine_id)
ON UPDATE CASCADE
ON DELETE RESTRICT;

-- 销售单明细表外键约束
ALTER TABLE SalesDetail
ADD CONSTRAINT fk_sales_detail_order 
FOREIGN KEY (sales_id) REFERENCES SalesOrder(sales_id)
ON UPDATE CASCADE
ON DELETE CASCADE;

ALTER TABLE SalesDetail
ADD CONSTRAINT fk_sales_detail_medicine 
FOREIGN KEY (medicine_id) REFERENCES Medicine(medicine_id)
ON UPDATE CASCADE
ON DELETE RESTRICT;
```

### 7.3 系统数据流与关系模式对应
```
管理员操作流：
   增删改查 Medicine
   增删改查 Supplier

采购员操作流：
   查询 Medicine, Supplier, Stock
   插入 PurchaseOrder, PurchaseDetail

库管员操作流：
   查询 Medicine, PurchaseOrder, PurchaseDetail, SalesOrder, SalesDetail
   更新 Stock

销售员操作流：
   查询 Medicine, Stock
   插入 SalesOrder, SalesDetail
```

### 7.4 关系模式设计原则遵循情况
1. **实体完整性**：所有表都有主键，且主键非空
2. **参照完整性**：所有外键都正确引用
3. **域完整性**：所有字段都有合适的数据类型和约束
4. **用户定义完整性**：业务规则通过CHECK约束实现
5. **避免冗余**：通过规范化设计减少数据冗余
6. **查询效率**：通过合理索引提高查询性能

### 7.5 各同学关注的关系模式重点

#### A同学重点：
- Medicine表的CRUD操作
- Supplier表的CRUD操作
- 基础数据的一致性维护

#### B同学重点：
- PurchaseOrder表的状态管理
- PurchaseDetail表的关联操作
- 与Supplier、Medicine表的外键关系

#### C同学重点：
- Stock表的实时更新
- 库存状态的自动计算
- 与所有业务表的关联查询

#### D同学重点：
- SalesOrder表的状态管理
- SalesDetail表的关联操作
- 库存检查机制的实现

---

本关系模式报告详细描述了系统的所有关系模式，包括属性定义、数据类型、约束条件、索引设计、数据依赖关系等。每个关系模式都严格遵循规范化理论，同时考虑了实际应用中的查询性能和业务需求。报告为四位同学的开发工作提供了清晰的数据结构指导，确保系统数据的一致性和完整性。